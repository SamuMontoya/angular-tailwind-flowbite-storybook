{"ast":null,"code":"import { formatPropInTemplate } from './angular-beta/ComputesTemplateFromComponent';\n/**\n * Converts an object of arguments to a string of property and event bindings and excludes undefined\n * values. Why? Because Angular treats undefined values in property bindings as an actual value and\n * does not apply the default value of the property as soon as the binding is set. This feels\n * counter-intuitive and is a common source of bugs in stories.\n *\n * @example\n *\n * ```ts\n * // component.ts\n * ㅤ@Component({ selector: 'example' })\n *  export class ExampleComponent {\n *   ㅤ@Input() input1: string = 'Default Input1';\n *   ㅤ@Input() input2: string = 'Default Input2';\n *   ㅤ@Output() click = new EventEmitter();\n *  }\n *\n * // component.stories.ts\n * import { argsToTemplate } from '@storybook/angular';\n * export const Input1: Story = {\n *  render: (args) => ({\n *    props: args,\n *    // Problem1: <example [input1]=\"input1\" [input2]=\"input2\" (click)=\"click($event)\"></example>\n *    // This will set input2 to undefined and the internal default value will not be used.\n *    // Problem2: <example [input1]=\"input1\" (click)=\"click($event)\"></example>\n *    // The default value of input2 will be used, but it is not overridable by the user via controls.\n *    // Solution: Now the controls will be applicable to both input1 and input2, and the default values will be used if the user does not override them.\n *    template: `<example ${argsToTemplate(args)}\"></example>`,\n *  }),\n *  args: {\n *    // In this Story, we want to set the input1 property, and the internal default property of input2 should be used.\n *    input1: 'Input 1',\n *    click: { action: 'clicked' },\n *  },\n * };\n * ```\n */\nexport function argsToTemplate(args, options = {}) {\n  const includeSet = options.include ? new Set(options.include) : null;\n  const excludeSet = options.exclude ? new Set(options.exclude) : null;\n  return Object.entries(args).filter(([key]) => args[key] !== undefined).filter(([key]) => {\n    if (includeSet) return includeSet.has(key);\n    if (excludeSet) return !excludeSet.has(key);\n    return true;\n  }).map(([key, value]) => typeof value === 'function' ? `(${key})=\"${formatPropInTemplate(key)}($event)\"` : `[${key}]=\"${formatPropInTemplate(key)}\"`).join(' ');\n}","map":{"version":3,"names":["formatPropInTemplate","argsToTemplate","args","options","includeSet","include","Set","excludeSet","exclude","Object","entries","filter","key","undefined","has","map","value","join"],"sources":["/Users/smontoyag/Documents/ui-kit/node_modules/@storybook/angular/dist/client/argsToTemplate.mjs"],"sourcesContent":["import { formatPropInTemplate } from './angular-beta/ComputesTemplateFromComponent';\n/**\n * Converts an object of arguments to a string of property and event bindings and excludes undefined\n * values. Why? Because Angular treats undefined values in property bindings as an actual value and\n * does not apply the default value of the property as soon as the binding is set. This feels\n * counter-intuitive and is a common source of bugs in stories.\n *\n * @example\n *\n * ```ts\n * // component.ts\n * ㅤ@Component({ selector: 'example' })\n *  export class ExampleComponent {\n *   ㅤ@Input() input1: string = 'Default Input1';\n *   ㅤ@Input() input2: string = 'Default Input2';\n *   ㅤ@Output() click = new EventEmitter();\n *  }\n *\n * // component.stories.ts\n * import { argsToTemplate } from '@storybook/angular';\n * export const Input1: Story = {\n *  render: (args) => ({\n *    props: args,\n *    // Problem1: <example [input1]=\"input1\" [input2]=\"input2\" (click)=\"click($event)\"></example>\n *    // This will set input2 to undefined and the internal default value will not be used.\n *    // Problem2: <example [input1]=\"input1\" (click)=\"click($event)\"></example>\n *    // The default value of input2 will be used, but it is not overridable by the user via controls.\n *    // Solution: Now the controls will be applicable to both input1 and input2, and the default values will be used if the user does not override them.\n *    template: `<example ${argsToTemplate(args)}\"></example>`,\n *  }),\n *  args: {\n *    // In this Story, we want to set the input1 property, and the internal default property of input2 should be used.\n *    input1: 'Input 1',\n *    click: { action: 'clicked' },\n *  },\n * };\n * ```\n */\nexport function argsToTemplate(args, options = {}) {\n    const includeSet = options.include ? new Set(options.include) : null;\n    const excludeSet = options.exclude ? new Set(options.exclude) : null;\n    return Object.entries(args)\n        .filter(([key]) => args[key] !== undefined)\n        .filter(([key]) => {\n        if (includeSet)\n            return includeSet.has(key);\n        if (excludeSet)\n            return !excludeSet.has(key);\n        return true;\n    })\n        .map(([key, value]) => typeof value === 'function'\n        ? `(${key})=\"${formatPropInTemplate(key)}($event)\"`\n        : `[${key}]=\"${formatPropInTemplate(key)}\"`)\n        .join(' ');\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,8CAA8C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAACC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC/C,MAAMC,UAAU,GAAGD,OAAO,CAACE,OAAO,GAAG,IAAIC,GAAG,CAACH,OAAO,CAACE,OAAO,CAAC,GAAG,IAAI;EACpE,MAAME,UAAU,GAAGJ,OAAO,CAACK,OAAO,GAAG,IAAIF,GAAG,CAACH,OAAO,CAACK,OAAO,CAAC,GAAG,IAAI;EACpE,OAAOC,MAAM,CAACC,OAAO,CAACR,IAAI,CAAC,CACtBS,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAKV,IAAI,CAACU,GAAG,CAAC,KAAKC,SAAS,CAAC,CAC1CF,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAK;IACnB,IAAIR,UAAU,EACV,OAAOA,UAAU,CAACU,GAAG,CAACF,GAAG,CAAC;IAC9B,IAAIL,UAAU,EACV,OAAO,CAACA,UAAU,CAACO,GAAG,CAACF,GAAG,CAAC;IAC/B,OAAO,IAAI;EACf,CAAC,CAAC,CACGG,GAAG,CAAC,CAAC,CAACH,GAAG,EAAEI,KAAK,CAAC,KAAK,OAAOA,KAAK,KAAK,UAAU,GAChD,IAAIJ,GAAG,MAAMZ,oBAAoB,CAACY,GAAG,CAAC,WAAW,GACjD,IAAIA,GAAG,MAAMZ,oBAAoB,CAACY,GAAG,CAAC,GAAG,CAAC,CAC3CK,IAAI,CAAC,GAAG,CAAC;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}